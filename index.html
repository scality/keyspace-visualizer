<!DOCTYPE html>
<meta charset="utf-8">
<title>Scality Keyspace visualizer</title>
<link rel="stylesheet" href="css/style.css">
<script src="js/d3.v3.js"></script>
<script src="js/functions.js"></script>
<!-- }}} -->

<body>
    <div class="radios">
        <div class="radio-group">
            <input type="radio" id="rcos0" name="radio-group"><label for="rcos0">Cos0</label>
            <input type="radio" id="rcos1" name="radio-group"><label for="rcos1">Cos1</label>
            <input type="radio" id="rcos2" name="radio-group" checked="checked"><label for="rcos2">Cos2</label>
            <input type="radio" id="rcos3" name="radio-group"><label for="rcos3">Cos3</label>
            <input type="radio" id="rcos4" name="radio-group"><label for="rcos4">Cos4</label>
            <input type="radio" id="rcos5" name="radio-group"><label for="rcos5">Cos5</label>
            <input type="radio" id="rarc12" name="radio-group"><label for="rarc12">Schema12</label>
            <input type="radio" id="rarc18" name="radio-group"><label for="rarc18">Schema18</label>
        </div>

        <div class="input-group">
            <input id="file-upload" class="datafile" type="file"/>
            <label for="file-upload" class="custom-file-upload">
                Upload a ringsh.txt file
            </label>
        </div>
    </div>

    <div class="info">Upload a ringsh.txt file to vizualize your keyspace.</div>

    <div id="wrapper">
        <div class="svg">
            <svg width="1200" height="1200"></svg>
        </div>

        <div id="infos"></div>
    </div>

    <div class="warning">TODO
        <ul>
            <li>Remove a slice when clicking on it, and rearrange the pie.</li>
            <li>Find a way to represent sites/diskgroups.</li>
            <li>Extend the large pie slice to the small pie when a line is over.</li>
            <li>Refactor the code to make it more readable.</li>
        </ul>
    </div>
    <div class="success">Color scheme updated.</div>
    <div class="success">The small pie in center is now updated with the appopriate colors.</div>

    <!-- Hidden Tooltip div -->
    <div class="tooltip"></div>

<script>
/* ------- Global variables to use {{{-------*/
var dataPie; // Store the datas for the pie chart
var dataAngles; // Store de datas for the line angles
var svg = d3.select("svg"),
    width = svg.attr("width"),
    height = svg.attr("height"),
	radius = Math.min(width, height) * 0.5,
    originx = width / 2,
    originy = height / 2;

/* Lines length used ot visualize angles */
var lineStart = radius * 0.1;
var lineLength = radius * 0.9;
var secondCircle = radius * 0.3

/**
 *  Palet of colors to use
 * SchemeSets appear in d3.v4.js
 * var colorsAvailable = d3.schemeSet1.concat(d3.schemeSet2).concat(d3.schemeSet3);
 */
var colorsAvailable = [
    "#e6194b", "#3cb44b", "#ffe119", "#0082c8", "#f58231",
    "#911eb4", "#46f0f0", "#f032e6", "#d2f53c", "#fabebe",
    "#008080", "#e6beff", "#aa6e28", "#fffac8", "#800000",
    "#aaffc3", "#808000", "#ffd8b1", "#000080", "#808080",
    "#FFFFFF", "#000000"
]

/* List of predefined angles */
var coses = {
    "rcos0": { "schema": 6, "part": [0] },
    "rcos1": { "schema": 6, "part": [0, 3] },
    "rcos2": { "schema": 6, "part": [0, 2, 4] },
    "rcos3": { "schema": 6, "part": [0, 3, 2, 5] },
    "rcos4": { "schema": 6, "part": [0, 3, 2, 5, 1] },
    "rcos5": { "schema": 6, "part": [0, 3, 2, 5, 1, 4] },
    "rarc12": { "schema": 12, "part": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] },
    "rarc18": { "schema": 18, "part": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17] }
};

/* ------- END: Global variables to use }}}-------*/
/* ------- DOM Selection {{{-------*/
// Group to handle key space slices pie chart
var RingImg = svg.append("g").attr("class", "pie");

/* Sclices */
RingImg.append("g").attr("class", "slices");
/* Tooltip texts */
RingImg.append("g").attr("class", "labels");
/* Lines */
svg.append("g").attr("class", "lines");
/* Arrows at the end of the lines */
svg.append("g").attr("class", "arrows");
var smallslices = svg.append("g").attr("class", "smpie");
smallslices.append("g").attr("class", "smslices");
/* Small center circle */
var smcircle = svg.append("g").attr("class", "smcircle").append("circle");
smcircle
    .attr("r", lineStart)
    .attr("stroke", "white")
    .attr("stroke-width", 2)
    .attr("fill", "none")
var lcircle =svg.append("g").attr("class", "lcircle").append("circle");
lcircle
    .attr("r", secondCircle)
    .attr("stroke", "white")
    .attr("stroke-width", 2)
    .attr("fill", "none")


/**
 *  Starting draw point in the svg
 *  Rotate -90Â° to start at noon
 */
svg.selectAll("g.lines, g.arrows, g.smcircle, g.lcircle, g.smslices, g.smpie")
    .attr("transform", "translate(" + originx + "," + originy + ") rotate(-90, 0, 0)");
// No need to rotate the pie chart
svg.selectAll("g.pie")
    .attr("transform", "translate(" + originx + "," + originy + ")");

// Hidden div to handle texts
var tooltip = d3.select("div.tooltip");

/* ------- END: DOM Selection }}}-------*/
/* ------- Standard configurations and function definitions {{{-------*/
var pie = d3.layout.pie()
	.sort(null)
	.value(function(d) { return parseInt(d.keysize) });

var arc = d3.svg.arc()          // slices configuration
    .cornerRadius(5)            // rounding the slices
    .padAngle(0)                // space between slices
	.outerRadius(function() { return radius * 0.8; } )  // size limit
	.innerRadius(function() { return radius * 0.4; } ); // starting draw

var smpie = d3.layout.pie()
    .sort(null)
    .value(function(d) { return d.angle; });
var smarc = d3.svg.arc()
    .cornerRadius(0)
    .padAngle(2 * Math.PI / 180)
    .outerRadius(function() { return radius * 0.3; } )
    .innerRadius(function() { return radius * 0.2; } );

/* ------- END: Standard function definitions and configurations }}}-------*/

/* ------- Reformating the input -------*/

// Handle input file {{{
d3.select("input.datafile")
    .on("change", function(d) {
        var file = d3.event.target.files[0];
        var reader = new FileReader();

        reader.onloadend = function(evt) {
            var dataURL = evt.target.result;
            d3.text(dataURL, function(d) {
                dataPie = formatInput(d);
                svg.select("g.smpie").html("")
                changedone = 0; //wait for "change" to finish before update angles
                change(dataPie);
                updateAngles(dataAngles);
            });
        };
        reader.readAsDataURL(file);
    }); // }}}

// Data example
d3.text("default-ringsh.txt", function(data) {
    dataPie = formatInput(data);
    change(dataPie);
    updateAngles(dataAngles);
});

// default lines view at init
dataAngles = partsToAngles(coses.rcos2);
updateAngles( dataAngles );
d3.selectAll('input[name="radio-group"]')
    .on("change", function() {
        labelType = this.id
        dataAngles = partsToAngles(coses[labelType]);
        updateAngles(dataAngles);
    });

var changedone = 0;
function change(data) { // {{{
	/* ------- PIE SLICES -------*/
	var slice = RingImg.select(".slices").selectAll("path.slice")
        .data(pie(data), function(d){ return d.data.label; });

	slice.enter()
		.insert("path")
		.attr("fill", function(d) { return d.data.colour; })
        .attr("class", function(d) { return "slice myshrtsrv" + d.data.host; })
        .attr("startangle", function(d) { return d.startAngle; })
        .attr("endangle", function(d) { return d.endAngle; })
        .style('opacity', 0.8)
        .on('mouseover', function (d, i) {
	        RingImg.select(".slices").selectAll("path.slice.myshrtsrv" + d.data.host)
            .transition()
            .duration(500)
            .ease('elastic')
            .style('opacity', 1)
            .attr('transform', function (d) {
                var dist = 30;
                d.midAngle = ((d.endAngle - d.startAngle) / 2) + d.startAngle;
                var x = Math.sin(d.midAngle) * dist;
                var y = -Math.cos(d.midAngle) * dist;
                return 'translate(' + x + ',' + y + ')';
            });
        })
        .on('mouseleave', function (d, i) {
	        RingImg.select(".slices").selectAll("path.slice.myshrtsrv" + d.data.host)
            .transition()
            .duration(500)
            .ease('bounce')
            .style('opacity', 0.8)
            .attr('transform', 'translate(0,0)')
        });

    slice
		.transition().duration(1000)
		.attrTween("d", function(d, i) {
			this._current = this._current || d;
            var interpolate = d3.interpolate(this._current, d);
			this._current = interpolate(0);
			return function(t) {
				return arc(interpolate(t));
			};
        });

	slice.exit()
		.remove();

	/* ------- TOOLTIPS -------*/
	var text = RingImg.select(".labels").selectAll("text")
        .data(pie(data), function(d){ return d.data.label; });

    function midAngle(d){
        return d.startAngle + (d.endAngle - d.startAngle)/2;
    }

	var tooltipaction = RingImg.select(".slices").selectAll("path.slice")
        .data(pie(data), function(d){ return d.data.label; });

    tooltipaction
        .on("mousemove", function(d){
            tooltip.style("left", d3.event.pageX+10+"px");
            tooltip.style("top", d3.event.pageY-25+"px");
            tooltip.style("display", "inline-block");
            tooltip.html(d.data.label);
        })
        .on("mouseout", function(d){
            tooltip.style("display", "none");
        });

    tooltipaction.exit()
        .remove();

    text.exit()
        .remove();
    changedone = 1;
}; // }}}

function updateAngles(data) {
    // Wait for data to be generated
    if(changedone != 1) {
        setTimeout(function() {
            updateAngles(data)
        }, 300);
        return;
    }
    var extraData = pie(dataPie)
    //console.table(extraData)

    var lines = svg.select("g.lines")
        .selectAll("line")
        .data(data, function(d) { return d.angle; });

    lines.enter()
        .append("line")
        .attr("x1", function(d) { return degreeToCosinus(d.angle) * lineStart; })
        .attr("y1", function(d) { return degreeToSinus(d.angle) * lineStart; })
        .attr("x2", function(d) { return degreeToCosinus(d.angle) * lineLength; })
        .attr("y2", function(d) { return degreeToSinus(d.angle) * lineLength; })
        .attr("fill", "none")
        .attr("stroke", "white")
        .attr("stroke-width", "2px")

    lines.exit().remove();

    var arcs = svg.select("g.smpie")
        .selectAll("path")
        .data(data, function(d, i) { return d.startAngle+d.endAngle+d.nbpart+d.schema });

    arcs.enter()
        .append("path")
        .attr("fill", function(d, i) {
            var x = -1; while(++x < extraData.length) {
                // We are at the end of the array, return the color
                if(x == extraData.length - 1) {
                    return extraData[x].data.colour;
                }
                if(degreeToRadian(d.endAngle) > (extraData[x].endAngle)) {
                    continue
                } else {
                    return extraData[x].data.colour;
                }
            }
        })
        .attr("transform", "rotate(90, 0, 0)")
        .attr("d", function(d, i) {
            var myarc = d3.svg.arc()
                .padAngle(degreeToRadian(0.5))
                .outerRadius(lineStart)
                .innerRadius(secondCircle)
                .startAngle(degreeToRadian( d.startAngle ))
                .endAngle(degreeToRadian( d.endAngle ));
            return myarc();
        })

    arcs.exit().remove();

    var anchor = svg.select("g.arrows")
        .selectAll("circle")
        .data(data, function(d) { return d.angle; });

    anchor.enter()
        .append("circle")
        .attr("cx", function(d) { return degreeToCosinus(d.angle) * lineLength; })
        .attr("cy", function(d) { return degreeToSinus(d.angle) * lineLength; })
        .attr("stroke", "white")
        .attr("stroke-width", "2px")
        .attr("r", 10)
        .attr("class", "circle")
        .attr("fill", function(d, i) { if(i == 0){return "green";}else{return "blue";} })

    anchor
        .on('mousedown', function(d, i) {
            var timedOut = 0
            svg.on('mousemove', function(elem, i) {
                    if(!timedOut) {
                        var x = originx - d3.mouse(this)[0];
                        var y = originy - d3.mouse(this)[1];
                        var radian = Math.atan2(y, x); // In radians
                        var degree = radian * (180 / Math.PI) + 180; 
                        //console.log("x:"+x+" y:"+y+" rad:"+rad+" deg:"+deg)
                        svg.selectAll("g.arrows, g.lines, g.smpie")
                            .attr("transform", "translate("+ originx +","+ originy +") rotate("+ degree +", 0, 0)");

                        arcs
                        .attr("fill", function(e, j) {
                            var newangle = degreeToRadian(e.endAngle) + radian - degreeToRadian(90);
                            while(newangle > degreeToRadian(360)) {
                                newangle = newangle - degreeToRadian(360);
                            }
                            while(newangle < 0) {
                                newangle = newangle + degreeToRadian(360);
                            }
                            var x = -1; while(++x < extraData.length) {
                                // We are at the end of the array, return the color
                                if(x == extraData.length - 1) {
                                        var a = degreeToRadian(e.endAngle) + radian - degreeToRadian(90)
                                    return extraData[x].data.colour;
                                }
                                if(newangle > (extraData[x].endAngle)) {
                                    continue
                                } else {
                                        var a = degreeToRadian(e.endAngle) + radian - degreeToRadian(90)
                                    return extraData[x].data.colour;
                                }
                            }
                        });
                    }

                    timedOut = 1
                    // add 10ms latency to not overlad the cpu
                    setTimeout(function() { timedOut = 0 }, 10)
                })
        .on('mouseup', function(e) {
            svg.on('mousemove', null);
        })
    });

    anchor.exit().remove();
};

</script>
</body>
</html>
